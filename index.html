<html>
<head>
<title>Tree of Knowledge</title>
<style>
body {
  margin: 0;
  padding: 0;
}
#canvasContainer {
  overflow: auto;
  width: 100vw;
  height: 600px;
}
.info-panel {
  position: absolute;
  background: white;
  border: 1px solid black;
  box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
  padding: 10px;
  z-index: 10;
  resize: both;
  overflow: auto;
  min-width: 200px;
  min-height: 100px;
}
.panel-header {
  font-weight: bold;
  margin-bottom: 10px;
}
.panel-content img, .panel-content video {
  max-width: 100%;
}
</style>
</head>
<body>
<select id="filter">
  <option value="all">All</option>
  <option value="philosophy">Philosophy</option>
  <option value="politics">Politics</option>
</select>
<div id="canvasContainer">
<canvas id="treeCanvas" width="800" height="600"></canvas>
</div>
<div id="infoPanels"></div>
<script>
const treeData = {
  label: 'Knowledge',
  category: 'root',
  content: {
    sentence: 'All knowledge.',
    paragraph: 'Knowledge encompasses various fields including philosophy, politics, social structures, and science.',
    essay: '<p>This is an essay about knowledge. It includes <img src="https://via.placeholder.com/150" alt="placeholder"> and <video controls src="https://www.w3schools.com/html/mov_bbb.mp4"></video></p>'
  },
  children: [
    {
      label: 'Philosophy',
      category: 'philosophy',
      content: {
        sentence: 'Study of fundamental questions.',
        paragraph: 'Philosophy addresses questions about existence, knowledge, values, reason, mind, and language.',
        essay: '<p>Philosophy is the study of general and fundamental questions. <img src="https://via.placeholder.com/150" alt="philosophy image"></p>'
      },
      children: [
        {
          label: 'Ethics',
          category: 'philosophy',
          content: {
            sentence: 'Moral principles.',
            paragraph: 'Ethics is the branch of philosophy that involves systematizing, defending, and recommending concepts of right and wrong behavior.',
            essay: '<p>Ethics, or moral philosophy, is concerned with questions of how persons ought to act. <video controls src="https://www.w3schools.com/html/mov_bbb.mp4"></video></p>'
          },
          children: []
        }
      ]
    },
    {
      label: 'Politics',
      category: 'politics',
      content: {
        sentence: 'Governance and power.',
        paragraph: 'Politics is the set of activities associated with making decisions in groups, or other forms of power relations between individuals.',
        essay: '<p>Politics involves the exercise of power and the making of decisions that affect groups of people. <img src="https://via.placeholder.com/150" alt="politics image"></p>'
      },
      children: []
    }
  ]
};

const canvas = document.getElementById('treeCanvas');
const ctx = canvas.getContext('2d');
let currentScale = 1;
let currentTranslateX = 0;
let currentTranslateY = 0;
let filteredTree = treeData;

assignPositions(filteredTree, 400, 300, 100, 100);

function assignPositions(node, x, y, dx, dy, parent = null) {
  node.x = x;
  node.y = y;
  node.parent = parent;
  const numChildren = node.children.length;
  if (numChildren > 0) {
    const startX = x - (numChildren - 1) * dx / 2;
    for (let i = 0; i < numChildren; i++) {
      assignPositions(node.children[i], startX + i * dx, y - dy, dx, dy, node);
    }
  }
}

function drawTree(node) {
  if (node.parent) {
    ctx.beginPath();
    ctx.moveTo(node.parent.x, node.parent.y);
    ctx.lineTo(node.x, node.y);
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(node.x, node.y, 10 / currentScale, 0, Math.PI * 2);
  ctx.stroke();
  ctx.fillText(node.label, node.x + 15 / currentScale, node.y);
  for (let child of node.children) {
    drawTree(child);
  }
}

function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(currentTranslateX, currentTranslateY);
  ctx.scale(currentScale, currentScale);
  drawTree(filteredTree);
  ctx.restore();
}

function getFilteredTree(filter) {
  if (filter === 'all') {
    return treeData;
  } else {
    const filteredChildren = treeData.children.filter(child => child.category === filter);
    return { ...treeData, children: filteredChildren };
  }
}

document.getElementById('filter').addEventListener('change', (e) => {
  const filter = e.target.value;
  filteredTree = getFilteredTree(filter);
  assignPositions(filteredTree, 400, 300, 100, 100);
  redraw();
});

let isPanning = false;
let startX, startY;
canvas.addEventListener('mousedown', (e) => {
  isPanning = true;
  startX = e.clientX;
  startY = e.clientY;
});
canvas.addEventListener('mousemove', (e) => {
  if (isPanning) {
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    currentTranslateX += dx;
    currentTranslateY += dy;
    startX = e.clientX;
    startY = e.clientY;
    redraw();
  }
});
canvas.addEventListener('mouseup', () => {
  isPanning = false;
});
canvas.addEventListener('mouseleave', () => {
  isPanning = false;
});
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const zoomAmount = e.deltaY * -0.01;
  currentScale *= (1 + zoomAmount);
  currentScale = Math.min(Math.max(0.5, currentScale), 4);
  redraw();
});
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = (e.clientX - rect.left - currentTranslateX) / currentScale;
  const mouseY = (e.clientY - rect.top - currentTranslateY) / currentScale;
  const node = findNodeAtPosition(mouseX, mouseY);
  if (node) {
    showInfoPanel(node);
  }
});

function findNodeAtPosition(x, y, tree = filteredTree) {
  if (Math.hypot(tree.x - x, tree.y - y) < 20 / currentScale) {
    return tree;
  }
  for (let child of tree.children) {
    const found = findNodeAtPosition(x, y, child);
    if (found) return found;
  }
  return null;
}

function showInfoPanel(node) {
  const panel = document.createElement('div');
  panel.className = 'info-panel';
  const rect = canvas.getBoundingClientRect();
  const screenX = rect.left + (node.x * currentScale + currentTranslateX);
  const screenY = rect.top + (node.y * currentScale + currentTranslateY);
  panel.style.left = `${screenX + 20}px`;
  panel.style.top = `${screenY + 20}px`;
  panel.innerHTML = `
    <div class="panel-header">${node.label}</div>
    <div class="panel-content">${node.content.essay}</div>
    <button onclick="this.parentElement.remove()">Close</button>
  `;
  document.getElementById('infoPanels').appendChild(panel);
  makeDraggable(panel);
}

function makeDraggable(element) {
  let isDragging = false;
  let offsetX, offsetY;
  element.addEventListener('mousedown', (e) => {
    if (e.target === element) {
      isDragging = true;
      offsetX = e.clientX - element.offsetLeft;
      offsetY = e.clientY - element.offsetTop;
    }
  });
  document.addEventListener('mousemove', (e) => {
    if (isDragging) {
      element.style.left = `${e.clientX - offsetX}px`;
      element.style.top = `${e.clientY - offsetY}px`;
    }
  });
  document.addEventListener('mouseup', () => {
    isDragging = false;
  });
}

redraw();
</script>
</body>
</html>
